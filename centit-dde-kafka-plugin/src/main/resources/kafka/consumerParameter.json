{
  "key.deserializer":{
    "describe":"key序列化类",
    "value":"org.apache.kafka.common.serialization.StringDeserializer",
    "help":"实现了接口org.apache.kafka.common.serialization.Serializer的key序列化类"
  },
  "value.deserializer":{
    "describe":"key序列化类",
    "value":"org.apache.kafka.common.serialization.StringDeserializer",
    "help":"实现了接口org.apache.kafka.common.serialization.Serializer的key序列化类"
  },
  "client.id":{
    "describe":"从服务器消费消息的时候向服务器发送的id字符串",
    "value":"null",
    "help":"从服务器消费消息的时候向服务器发送的id字符串"
  },
  "group.id":{
    "describe":"用于唯一标志当前消费者所属的消费组的字符串",
    "value":"dde.default.consumer.group",
    "help":"用于唯一标志当前消费者所属的消费组的字符串。如果消费者使用组管理功能如subscribe(topic)或使用基于Kafka的偏移量管理策略，该项必须设置。"
  },
  "auto.offset.reset":{
    "describe":"自动重置偏移量参数",
    "value":"null",
    "help":"earliest：自动重置偏移量到最早的偏移量;\nlatest：自动重置偏移量为最新的偏移量;\nnone：如果消费组原来的（previous）偏移量不存在，则向消费者抛异常;\nanything：向消费者抛异常"
  },
  "enable.auto.commit":{
    "describe":"如果设置为true，消费者会自动周期性地向服务器提交偏移量",
    "value":"null",
    "help":"如果设置为true，消费者会自动周期性地向服务器提交偏移量。"
  },
  "auto.commit.interval.ms":{
    "describe":"如果设置了enable.auto.commit的值为true，则该值定义了消费者偏移量向Kafka提交的频率",
    "value":"null",
    "help":"如果设置了enable.auto.commit的值为true，则该值定义了消费者偏移量向Kafka提交的频率"
  },
  "fetch.min.bytes":{
    "describe":"服务器对每个拉取消息的请求返回的数据量最小值",
    "value":"null",
    "help":"服务器对每个拉取消息的请求返回的数据量最小值"
  },
  "fetch.max.wait.ms":{
    "describe":"如果服务器端的数据量达不到fetch.min.bytes的话，服务器端不能立即响应请求",
    "value":"null",
    "help":"如果服务器端的数据量达不到fetch.min.bytes的话，服务器端不能立即响应请求。该时间用于配置服务器端阻塞请求的最大时长。"
  },
  "fetch.max.bytes":{
    "describe":"服务器给单个拉取请求返回的最大数据量",
    "value":"null",
    "help":"服务器给单个拉取请求返回的最大数据量。消费者批量拉取消息，如果第一个非空消息批次的值比该值大，消息批也会返回，以让消费者可以接着进行。即该配置并不是绝对的最大值。broker可以接收的消息批最大值通过message.max.bytes(broker配置)或max.message.bytes(主题配置)来指定。"
  },
  "connections.max.idle.ms":{
    "describe":"在这个时间之后关闭空闲的连接",
    "value":"null",
    "help":"在这个时间之后关闭空闲的连接"
  },
  "check.crcs":{
    "describe":"自动计算被消费的消息的CRC32校验值",
    "value":"null",
    "help":"自动计算被消费的消息的CRC32校验值。可以确保在传输过程中或磁盘存储过程中消息没有被破坏.它会增加额外的负载，在追求极致性能的场合禁用。"
  },
  "exclude.internal.topics":{
    "describe":"是否内部主题应该暴露给消费者。",
    "value":"null",
    "help":"是否内部主题应该暴露给消费者。如果该条目设置为true，则只能先订阅再拉取。"
  },
  "isolation.level":{
    "describe":"控制如何读取事务消息",
    "value":"read_uncommitted",
    "help":"控制如何读取事务消息;read_committed和read_uncommitted(默认值)"
  },
  "heartbeat.interval.ms":{
    "describe":"当使用消费组的时候，该条目指定消费者向消费者协调器发送心跳的时间间隔",
    "value":"null",
    "help":"当使用消费组的时候，该条目指定消费者向消费者协调器发送心跳的时间间隔"
  },
  "session.timeout.ms":{
    "describe":"当使用Kafka的消费组的时候，消费者周期性地向broker发送心跳数表明自己的存在",
    "value":"null",
    "help":"当使用Kafka的消费组的时候，消费者周期性地向broker发送心跳数表明自己的存在。如果经过该超时时间还没有收到消费者的心跳，则broker将消费者从消费组移除，并启动再平衡。该值必须在broker配置group.min.session.timeout.ms和group.max.session.timeout.ms之间。"
  },
  "max.poll.records":{
    "describe":"一次调用poll()方法返回的记录最大数量",
    "value":"null",
    "help":"一次调用poll()方法返回的记录最大数量"
  },
  "max.poll.interval.ms":{
    "describe":"使用消费组的时候调用poll()方法的时间间隔",
    "value":"null",
    "help":"使用消费组的时候调用poll()方法的时间间隔。该条目指定了消费者调用poll()方法的最大时间间隔。如果在此时间内消费者没有调用poll()方法，则broker认为消费者失败，触发再平衡，将分区分配给消费组中其他消费者。"
  },
  "max.partition.fetch.bytes":{
    "describe":"对每个分区，服务器返回的最大数量.消费者按批次拉取数据",
    "value":"null",
    "help":"对每个分区，服务器返回的最大数量.消费者按批次拉取数据。如果非空分区的第一个记录大于这个值，批处理依然可以返回，以保证消费者可以进行下去。broker接收批的大小由message.max.bytes（broker参数）或max.message.bytes（主题参数）指定。"
  },
  "send.buffer.bytes":{
    "describe":"用于TCP发送数据时使用的缓冲大小（SO_SNDBUF），-1表示使用OS默认的缓冲区大小",
    "value":"null",
    "help":"用于TCP发送数据时使用的缓冲大小（SO_SNDBUF），-1表示使用OS默认的缓冲区大小"
  },
  "retry.backoff.ms":{
    "describe":"在发生失败的时候如果需要重试，则该配置表示客户端<等待多长时间再发起重试",
    "value":"null",
    "help":"在发生失败的时候如果需要重试，则该配置表示客户端<等待多长时间再发起重试。该时间的存在避免了密集循环"
  },
  "request.timeout.ms":{
    "describe":"客户端等待服务端响应的最大时间",
    "value":"null",
    "help":"客户端等待服务端响应的最大时间。如果该时间超时，则客户端要么重新发起请求，要么如果重试耗尽，请求失败。"
  },
  "reconnect.backoff.ms":{
    "describe":"重新连接主机的等待时间",
    "value":"null",
    "help":"重新连接主机的等待时间。避免了重连的密集循环。该等待时间应用于该客户端到broker的所有连接"
  },
  "reconnect.backoff.max.ms":{
    "describe":"重新连接到反复连接失败的broker时要等待的最长时间（以毫秒为单位）",
    "value":"null",
    "help":"重新连接到反复连接失败的broker时要等待的最长时间（以毫秒为单位）。如果提供此选项，则对于每个连续的连接失败，每台主机的退避将成倍增加，直至达到此最大值。在计算退避增量之后，添加20％的随机抖动以避免连接风暴。"
  },
  "receive.buffer.bytes":{
    "describe":"TCP连接接收数据的缓存（SO_RCVBUF）",
    "value":"null",
    "help":"TCP连接接收数据的缓存（SO_RCVBUF）。-1表示使用操作系统的默认值。"
  },
  "partition.assignment.strategy":{
    "describe":"当使用消费组的时候，分区分配策略的类名",
    "value":"null",
    "help":"当使用消费组的时候，分区分配策略的类名"
  },
  "metrics.sample.window.ms":{
    "describe":"计算指标样本的时间窗口",
    "value":"null",
    "help":"计算指标样本的时间窗口"
  },
  "metrics.recording.level":{
    "describe":"指标的最高记录级别",
    "value":"null",
    "help":"指标的最高记录级别"
  },
  "metrics.num.samples":{
    "describe":"用于计算指标而维护的样本数量",
    "value":"null",
    "help":"用于计算指标而维护的样本数量"
  },
  "interceptor.classes":{
    "describe":"拦截器类的列表,默认没有拦截器拦截器是消费者的拦截器",
    "value":"null",
    "help":"拦截器类的列表。默认没有拦截器拦截器是消费者的拦截器，该拦截器需要实现org.apache.kafka.clients.consumer.ConsumerInterceptor接口。拦截器可用于对消费者接收到的消息进行拦截处理。"
  }
}